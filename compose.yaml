# ==============================================================================
# Podman Compose — Chatbot RAG
# 5 services : PostgreSQL+pgvector, Redis, Web (Django), Celery, Nginx
# ==============================================================================

version: '3.8'

services:
  # ==========================================================================
  # 1. Base de données — PostgreSQL avec extension pgvector
  #    Remplace ChromaDB : vecteurs et données relationnelles dans une seule DB
  # ==========================================================================
  db:
    image: docker.io/pgvector/pgvector:pg16
    container_name: chatbot-db
    restart: unless-stopped

    environment:
      POSTGRES_DB:       chatbot_rag
      POSTGRES_USER:     chatbot
      POSTGRES_PASSWORD: ${DB_PASSWORD:-changeme}

    volumes:
      - pgdata:/var/lib/postgresql/data:Z

    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U chatbot -d chatbot_rag"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # ==========================================================================
  # 2. Redis — broker Celery + backend résultats
  # ==========================================================================
  redis:
    image: docker.io/library/redis:7-alpine
    container_name: chatbot-redis
    restart: unless-stopped

    command: redis-server --appendonly yes

    volumes:
      - redis_data:/data:Z

    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # ==========================================================================
  # 3. Application Web — Django + Gunicorn
  # ==========================================================================
  web:
    build:
      context: .
      dockerfile: Containerfile
    image: chatbot-rag:v1
    container_name: chatbot-web
    restart: unless-stopped

    user: "1001:1001"

    ports:
      - "8002:8000"   # 8002 sur l'hôte (8001 = noScribe-portal)

    # DNS académie + fallback public (même que noScribe)
    dns:
      - 10.222.200.100
      - 172.30.8.20
      - 1.1.1.1

    env_file:
      - .env

    environment:
      # Surcharges spécifiques au conteneur
      DB_HOST:                  db
      CELERY_BROKER_URL:        redis://redis:6379/0
      CELERY_RESULT_BACKEND:    redis://redis:6379/0

    volumes:
      - ./media:/app/media:U
      - ./logs:/app/logs:U

    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ==========================================================================
  # 4. Worker Celery — vectorisation asynchrone des documents
  # ==========================================================================
  celery:
    build:
      context: .
      dockerfile: Containerfile
    image: chatbot-rag:v1
    container_name: chatbot-celery
    restart: unless-stopped

    user: "1001:1001"

    command: celery -A chatbot_rag worker --loglevel=info --concurrency=2

    dns:
      - 10.222.200.100
      - 172.30.8.20
      - 1.1.1.1

    env_file:
      - .env

    environment:
      DB_HOST:                  db
      CELERY_BROKER_URL:        redis://redis:6379/0
      CELERY_RESULT_BACKEND:    redis://redis:6379/0

    volumes:
      - ./media:/app/media:U
      - ./logs:/app/logs:U

    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      web:
        condition: service_healthy

  # ==========================================================================
  # 5. Reverse proxy — Nginx
  # ==========================================================================
  nginx:
    image: docker.io/library/nginx:alpine
    container_name: chatbot-nginx
    restart: unless-stopped

    ports:
      - "8182:80"     # 8182 sur l'hôte (8180 = noScribe-nginx)

    volumes:
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      - ./staticfiles:/app/staticfiles:ro
      - ./media:/app/media:ro

    depends_on:
      web:
        condition: service_healthy

# ==============================================================================
# Volumes persistants
# ==============================================================================
volumes:
  pgdata:
    driver: local
  redis_data:
    driver: local
